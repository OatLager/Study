C++
- 자료형
  - void : 반환 값이 없는 경우 사용. 
  
- 변수 & 메모리 종류

  (변수)
  1. 지역변수
     - *메모리 스택 영역
     - 해당 함수/구역에서 사용 가능한 변수
  2. 전역변수
     - *메모리 데이터 영역
     - 해당 파일 내에서 사용 가능한 변수
  3. 정적변수(static)
     - *메모리 데이터 영역
     - 선언된 곳(파일, 함수) 내에서 전용으로 사용되는 변수. 
     - 전역변수와 달리 사용 영역이 구분되기 때문에 변수명이 같아도 서로 영향없이 사용 가능.
     - 전역변수에서 사용 영역을 제한한 것이 정적변수, 변수의 보호 및 안정성이 높다. 
     - 의도하지 않은 상황에서 변수가 변하는 것을 방지 할 수 있다. 
     - ex) static int g_iStatic = 0;
        -> 정수형 정적변수 g_iStatic을 선언하고 초기값이 0 이다 라는 의미. 
        -> 컴파일 과정에서 최초 한번만 동작 한다. 따라서 정적변수가 선언된 함수or파일이 중복 사용되도 초기화되지 않는다. 
        -> 포인터를 통해 주소에 직접 접근해 강제로 바꿔줄 수는 있다. 
  4. 외부변수(exturn)
     - *메모리 데이터 영역
     - 여러 파일에서 똑같이 인식할 수 있는 변수를 사용하고 싶을 때. 
     - 외부변수 선언시 값을 지정하면 안된다. (해당 변수가 어딘가에 있으니 사용해도 된다 알려주는 의미) 
        -> ex) exturn int g_iExtern
     - 어떤 파일에서든 선언한 외부변수의 사용이 있어야 한다.
        -> g_iExtern = 0; 
        -> 링크단계에서 exturn int g_iExtern 을 선언한 파일에서 어딘가에 사용된 외부변수가 연결되어 사용 가능하게 됨.
        

  (메모리)
  1. Stack 영역
     - 함수 시작 시 생성 / 종료 시 해제
  2. Data 영역
     - 프로그램 시작 시 생성 / 종료 시 해제
  3. 읽기 전용(코드, ROM)
  4. 힙 영역역

  * Stack : 선입후출, 후입선출 구조
  * Queue : 선입선출, 후입후출 구조 
  

- 함수
  - Stack 구조 
      * 재귀함수 : 함수 내에서 자기 자신을 호출하는 함수.
                   가독성, 구현의 용이. 그러나 성능이 떨어짐(느리다) 
               
- 분할구현 
  - Header(.h)와 cpp(.cpp) 파일을 분리하여 생성. 
  - Header : 함수/변수의 선언.
  - cpp : 함수의 정의/구현. 
   
  - 분할구현의 문제

- 클래스(Class)
  - 접근 제한 지정자(private, protected, public)로 내부 분류
     - private : 비공개, 외부 파일에서 접근 불가. 
     - public : 공개, 외부 파일에서 접근 가능, 변경 가능. 
     - protected : 상속,
    
  - 생성자 라는 초기화 함수를 제공한다.
     - 본인 클래스명이랑 똑같은 이름의 함수('클래스명()'), 반환타입이 없다. 
     - 생성자는 객체가 만들어질때 자동으로 호출된다. (컴파일 과정의 규칙) 
     - 생성자에서 초기화(이니셜라이져) 문법을 제공한다. 
        - ex) 클래스명() : 초기화, 초기화, ...  
  - 소멸자 : 객체가 없어질때 자동으로 실행, 생성자와 반대 개념 
     - ex) ~클래스명()  
  - 생성자/소멸자를 따로 작성하지않으면 문법상 필요하기 때문에 컴파일 과정에서 자동으로 생성됨. 그러나 아무 기능이 없음. 
  
  - 멤버함수 생성/사용 가능. 
     - 해당 클래스가 사용하는 전용함수.
        * 멤버함수를 이용하여 private에 지정된 변수 변경도 가능. 
     - 멤버함수 사용시 반드시 클래스가 실체화된 객체가 필요. 
        - ex) 클래스   : CMy
                객체   : c 
              멤버함수 : Set()
              -> CMy c; 
                 c.Set(); 
              -> CMy::Set(); 와 같이 직접적으로 접근 불가하다. 
                 클래스::멤버함수, '::' : 범위지정연산자. 
           
    - 클래스 멤버함수의 특징. 
       구조체 설계에서는 멤버함수(* 객체, 변수) 방식, 해당 객체를 지정하여 사용.   
       클래스 멤버함수는 '객체.멤버함수'로 객체를 통해 호출하여 해당 객체의 주소가 this 포인터로 자동 전달됨.  
       this : 포인터, 주소타입, 객체를 지칭함. 멤버함수의 지역변수, 생략되어있다. 
 
  - 대입 연산자
    - 작성하지 않으면 자동으로 생성됨 
    - 내가만든 객체 끼리의 연산이 수행되면 실행.
        ex) 클래스  : CMy
              객체  : c2, c3
            연산자  : = 
            -> CMy c2;
               CMy c3; 
               c3 = c2 
               
    -  클래스 내부 멤버함수로 작성
           CMy& operator = (const CMy& _Other) 
           {
                m_i = _Other.m_i;   
                return *this; 
           }
    - 오버로딩 : 내가만든 자료형 객체끼리의 연산을 할 때 기존의 연산자와 동일한 이름으로 함수를 구현 할 수 있, 연산자의 기능 추가.  

  - 레퍼런스    
    - 레퍼런스는 포인터와 유사. 
      참조형태로 원본을 복사하여 비용, 부담이 적음. 
      그러나 레퍼런스는 한번 참조하면 다른 대상을 참조 할 수 없다. 
      참조한 대상과 동일시됨. -> 포인터처럼 역참조 연산을 할 필요가 없음.   
      레퍼런스를 변경하면 참조한 대상(원본)도 변경됨. 직접적으로 원본 수정.
      - 포인터 : 주소를 가져옴
      - 레퍼런스 : 대상(원본)을 참조
    - const 레퍼런스 
      레퍼런스 변경시 원본 수정 불가. 
      
      
- 자료형 변수 활용
  - 자료형 * 변수명 : 포인터 변수 선언
  - * 포인터변수 : 포인터 주소 역참조
  - &변수 : 변수의 주소값
  - 자료형& 변수명 : 레퍼런스 변수 선언


- 상속
  - 클래스에서 반복적으로 자주 구현되는 기능을 상속을 통해 다른 클래스에서도 사용 할 수 있음.
  - ex) class child : public parent
  - 메모리는 부모클래스부터 순차적으로 할당 된다.  
  - 부모 클래스의 멤버변수, 멤버함수를 사용할 수 있다. 
  
  - 상속에서 생성자가 동작하는 방식
    - 생성자를 통한 초기화(이니셜라이져)시 각 클래스 쪽에서 해당한는 멤버변수/함수의 초기화를 수행한다.
      ex) child() : parent변수 초기화, .... -> 불가능 
      but) chile() : ... {parent변수 = 0;} -> 가능 

    - 생성자는 자식클래스에서 부모클래스 순으로 호출된다. 
      실행완료는 반대순서로. 따라서 부모클래스 먼저 초기화가 된다. 

    - 부모생성자를 따로 작성하였을 때 
      자식클래스에서 따로 만든 생성자를 호출하고 싶을 때 
      자식 생성자 초기화에 명시해주어야 한다. 
      ex) child() : parent(), ... 

  - 상속에서 소멸자가 동작하는 방식
    - 소멸자는 호출 뿐만아니라 실행도 자식클래스 먼저 수행하고 부모클래스가 수행된다. 

  - 오버 라이딩 : 재정의
    - 상속관계에서만 사용 가능
    - 부모클래스, 자식클래스에서 같은 함수가 존재할 경우
    - 부모클래스 멤버함수를 자식클래스에서 재정의 했다 라는 의미
      따라서 자식클래스 객체를 통해 함수를 호출하면 자식클래스의 멤버함수가 호출/실행 된다. 
    - 부모클래스 멤버함수를 사용하고 싶을 경우
      ex) child.CParent::func() 방식으로 사용 가능.
      
  - 오버 로딩
    - 함수 이름이 똑같을 때, 인자타입의 차이로 인한 구별
